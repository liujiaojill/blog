# 问题
假设我开了一个创业公司，现在邀请一批老伙伴加入公司，一起吃饼。这时候我收到了这些回复：
1. ok, i will do it
2. okie dokie
3. Ahooy, Okay!!!
4. why sure, i can go
5. arrr, yes matey
6. My answer me mate, is yes y

现在我要找到回复中肯定的词语。比如
1. ok 
2. Okay 
3. sure 
4. yes 
5. y

应该怎么做呢？

## 单词边界
从最简单的开始，先匹配ok。

```javascript
/ok/
```

结果第二行的okie也被匹配了，这是什么鬼，我们不应该匹配第2行。还记得《正则表达式2》里面讲的部分匹配的问题，但是这里不能用那个解决方案，因为ok后面还有很多东西呢。所以这里介绍一个边界元字符（Boundary metacharacter）`\b`。

这样写就可以正确匹配ok单词了

```javascript
/\bok\b/
```

**`\b`确保匹配整个单词** 

## 匹配多个和“可以选择的”
现在ok匹配上了，我们需要匹配Okay了。直接把Okay放在后面可以的。

```javascript
/\bok\b|\bokay\b/
```

这样可以的。但是如果有更多的可能性呢，这样就不好了，我们换一种吧。如果能让`ay`是可选的，就可以简化了吧。这里介绍`?`.看看下面代码

```javascript
/\bok(ay)?\b/i
```

这样就可以匹配ok和okay了，**`?`表示出现0次或者1次，就是可以选择的意思**


## Or破坏了单词边界

下面我们来看看如何匹配sure，很显然可以想到。

```javascript
/\bok(ay)?|sure\b/i
```

这个可以匹配sure，可是也可以匹配ensure，因为左边没有`\b`了。解决的方法是用group

```javascript
/\b(ok(ay)?|sure)\b/i
```

## 结局

剩下的yes和y应该很好解决了，看一下代码吧

```javascript
/\b(ok(ay)?|sure|y(es)?)\b/i
```

# 奖励
正则表达式太牛逼了，忍不住我再学习点。

## 如何表达非
前面我们都是去匹配，那么我们不想匹配一些东西怎么办，比如，要匹配所有不是数字的？看看这个：

```javascript
/[a-z\s,]+/i
```

这样写不错，但是还可以这样

```javascript
/[^\d]+/i
```

等等，`^`不是表示一行以模式开头吗？嗯，在[]中它表示否定。不要混淆了。`/^[^\d]+$/`看这个里面两个`^`是不同的意思。

## 相反意思的元字符

| 元字符 | 描述 |
| ------------- | ------------- |
| \w | 查找单词字符 |
| \W | 查找非单词字符 |
| \d | 查找数字 |
| \D | 查找非数字字符 |
| \b | 匹配单词边界 |
| \B | 匹配非单词边界 |

呵呵，其实直接用`/^\D+$/`就可以查找所有非数字了。

## 限制数字
我们知道`[]`里面的表达式只能匹配一个字符，`?`表示出现0次或者1次，就是可以选择的意思，`+`表示出现1次或者大于1次，那么有没有其他的量词呢：

| 量词 | 描述 |
| ------------- | ------------- |
|n+	|匹配任何包含至少一个 n 的字符串。|
|n*	|匹配任何包含零个或多个 n 的字符串。|
|n?	|匹配任何包含零个或一个 n 的字符串。|
|n{X}	|匹配包含 X 个 n 的序列的字符串。|
|n{X,Y}	|匹配包含 X 或 Y 个 n 的序列的字符串。|
|n{X,}	|匹配包含至少 X 个 n 的序列的字符串。|
|n$	|匹配任何结尾为 n 的字符串。|
|^n	|匹配任何开头为 n 的字符串。|
|?=n	|匹配任何其后紧接指定字符串 n 的字符串。|
|?!n	|匹配任何其后没有紧接指定字符串 n 的字符串。|

举个例子吧：

```javascript
/[a-z]{1,3}/
```
上面这个表达式可以匹配：`'t','te','tes'`，但是`'test'`就不能匹配了，最多1个祖父到三个字符。

### 语法
> {最少匹配的数目, 最多匹配的数目}


